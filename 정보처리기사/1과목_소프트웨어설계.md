# 🚀 제1과목 소프트웨어 설계


## 📌 키워드 정리

### GoF의 디자인 패턴 ⭐ 
1. 생성 패턴 : 객체의 생성 방식을 결정하는 패턴
+ Builder : 작게 분리된 인스턴스를 건축하듯이 **조합**하여 객체를 생성. 인스턴스를 생성자를 통해 직접 생성하지 않고, 내부 클래스(Builder)를 통해 간접적으로 생성함 [건축가]
+ Prototype : 원본(프로토타입)을 먼저 생성하고 인스턴스를 **복제**하여 사용
+ Singleton : 클래스 내에서 인스턴스는 **하나뿐**이며, 이에 대한 접근점 제공 [식당의 정수기]
+ Abstract factory : 인터페이스를 통해 서로 연관 및 의존하는 객체들의 그룹을 생성해 추상적으로 표현함. 서로 다른 부품을 조립한다. (Kit) [조립 공장]
+ Factory Method : 상위 클래스에선 인터페이스만 정의, 실제 생성은 서브 클래스에서 수행. 부품부터 완성품까지 통째로 찍어낸다. (Visual-Constructor 패턴) [공장]

2. 구조 패턴 : 객체를 조직화하는데 유용한 패턴
+ **Adapter** : 기존 클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 변환 [변압기]
+ **Bridge** : 기능과 구현을 두 개의 별도 클래스로 구현 [다리]
+ Composite : 부분과 전체의 계층을 표현하기 위해 객체들을 모아 **트리** 구조로 구성
+ Decorator : 객체 간 결합을 통해 **기능 확장** [장식된 눈사람]
+ Facade : 서브 시스템에 있는 인터페이스 집합에 통합된 하나의 인터페이스를 제공 -> 의사소통 및 종속성 최소화 목표 [리모콘]
+ Flyweight : 객체의 내부에서 참조하는 객체를 직접 만들지 않고, 가능한 공유해서 사용해서 **메모리 절약**
+ Proxy : 실제 기능을 수행하는 객체 대신 가상의 객체(Proxy Object)를 사용해 로직의 흐름 제어

3. 행위 패턴 : 객체의 행위를 조직, 관리, 연합하는데 사용하는 패턴
+ Template method : 상위 클래스에서 **골격** 정의, 하위 클래스에서 세부 처리 구체화
+ Iterpreter : 언어에 **문법** 표현 정의
+ Iterator : 내부 표현부 노출 없이 객체 집합의 원소에 **순차적으로** 접근 (커서 Cursor)
+ Command : **실행된 기능(명령어)을 캡슐화**, 재사용성 높음 (작동 Action, 트랜잭션 Transaction)
+ Chain of Responsibility : 요청이 해결될 때까지 체인을 따라 책임이 넘어감
+ State : **객체의 내부 상태**에 따라 객체의 행위 내용 변경
+ Strategy : **행위를 클래스로 캡슐화**, 동적으로 행위를 자유롭게 바꿀 수 있도록
+ Mediator : **중재자**를 통해 객체들의 상호작용을 독립적으로 다양화시킴
+ Memento : 객체의 상태 정보를 저장하고 사용자 수요에 따라 원하는 시점의 데이터를 **복원** (토큰 Token)
+ **Visitor** : **방문자**는 각 클래스를 방문하여 분리된 처리 기능 수행 [책을 만들기 위해 저자, 편집자, 홍보팀을 번갈아 방문]
+ **Observer** : 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동, **1:n의 객체 의존 관계**


### 객체지향 프로그래밍 ⭐
1. 구성 : 메서드, 객체, **클래스**, 메시지(객체 간 통신), 모듈
2. 기법 : **캡슐화, 추상화, 다형성, 정보은닉, 상속성**
        
        추상화 : 자료추상화, 제어 추상화, 과정 추상화
        캡슐화 : 속성+메서드 묶어 객체로 구성 -> Readability & 재사용성 향상, 정보 은닉
        다형성 : 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질, 오버로딩 vs 오버라이딩
3. 클래스 사이의 관계
        
        일반화(Generalization) : IS-A, 상속
        연관(Association) : HAS-A
        의존(Dependency) : 한 클래스가 다른 클래스를 오퍼레이션의 매개변수로 사용, 명세가 바뀌면 다른 사물에 영향을 줌
        집합연관(집약관계, Aggregation) : 전체 객체의 라이프타임과 부분 객체의 라이프타임이 독립적
        복합연관(합성관계, Composition) : 전체 객체의 라이프타임과 부분 객체의 라이프타임이 동일, CASCADE 같은 특성
        실체화관계(Realization)
        
5. 객체지향 분석(OOA) 방법론: **럼바우**, Coad와 Yourdon, 부치 등
    + **럼바우 방법 : 객체 모델링[객체 다이어그램]-> 동적 모델링 [상태 다이어그램] -> 기능 모델링 [자료 흐름도 DFD]**
    + 부치 : 동사 명사 선택, Use case 강조
    + Coad와 Yourdon 방법 : E-R 다이어그램
    + Wirfs-Brock 방법 : 분석과 설계의 구분 X
6. 원칙
    + SRP (Single Responsibility Principle, 단일 책임 원칙) : 객체는 단 하나의 책임만을 가져야 한다. 어떤 클래스를 변경하는 이유는 오직 하나뿐이어야 한다.
    + OCP (Open-Closed Principle, 개방 폐쇄 원칙) 기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.
    + LSP (Liskov Subtitution Principle, 리스코프 교체의 원칙) : 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있어야 한다.
    + ISP (Interfact Segregation Principle, 인터페이스 분리의 원칙) : 인터페이스를 클라이언트에 특화되도록 분리하여야 햔다.
    + DIP (Dependency Inversion Principle, 의존 역전 원칙) : 의존 관계를 맺을 때 변화가 쉬운 것보다는 변화가 어렵고 변화가 거의 없는 것에 의존해야 한다.
 
 
### DFD (데이터 흐름도, Data Flow Diagram)
        process -> data flow -> data store -> terminator
+ 자료흐름도, 자료사전 -> 구조적 방식 방법론


### DD (자료 사전)
= 정의, + 연결, () 생략, [|] 선택, {} 반복, " 설명



### UML 다이어그램 ⭐
+ 특징 : 가시화 언어, 구축 언어, 문서화 언어, 명세화 언어
+ 종류
1. 구조적(정적) Structural 다이어그램 : **class, object, component**, deployment, package, composite structure
2. 행위(동적) Behavior 다이어그램 : **use case**, **state** 상태 간의 전이 표현, **activity** 순서적 흐름 표시
3. ㄴ 상호작용 Interaction 다이어그램 : sequence, communication, interaction overview, timing
391p

### UML 스테레오 타입
<< >> 안에 기술
include, extends, interface, exception, constructor
### USECASE 모델 ⭐
1. 정의 : **사용자의 입장**에서 본 시스템의 행동 표현
2. 구성 요소 : 시스템, 액터, 유스케이스, 관계


        시스템 : 만들고자 하는 프로그램, 사각형 틀로 표현
        액터 : 시스템의 외부에서 시스템과 상호작용을 하는 사람(**사용자 액터**) 혹은 다른 시스템, 졸라맨으로 표현
        유스 케이스 : 사용자 입장에서 바라본 시스템의 기능
        관계 : 액터와 유스 케이스 사이의 의미 있는 관계 - 연관 Association, 포함 Include, 확장 Extend, 일반화 Generalization
                + 다이어그램 B extend A : A 유즈케이스 수행 중 특정 조건 만족하면 B 유즈케이스 수행 

3. 검증 단계 : 유즈케이스마다 분석 클래스가 적절히 도출되었고, 제어 클래스의 도출 등이 충분하고 상세하게 도출되어 클래스의 역할, 클래스 간 관계, 메시지 흐름 등을 확인할 수 있는지 검토 -> **경계 Boundary, 엔티티 Entity, 제어 Control 클래스**
393

### HIFO (Hierarchy Input Output)
기능과 자료의 의존 관계를 동시에 표현할 수 있는 하향식 소프트웨어 개발 도구

HIPO 차트 종류 : 가시적 도표(Tree 구조), 총체적 도표(기능 기술), 세부적 도표(상세 기술)


### 코드 설계
연상 코드, 블록 코드(블럭으로 나누어 일련 코드), 블럭 순서 코드(군 설정), 그룹 분류 코드, 10진 분류 코드 ex) 10진 분류표, 순차 코드, 끝자리 분류 코드, 연상 코드, 합성 코드, 표의 숫자 코드 등


### 소프트웨어 설계
1. 목표: 낮은 결합도 (모듈과 모듈 사이), 높은 응집도 (모듈 내부 구성 요소 간)
2. 상위 설계 vs 하위 설계



### 소프트웨어 생명주기 모형
+ 나선형 모형(Sprial Model) : 계획 수립 - 위험 분석 - 개발 및 검증 - 고객 평가. 테스트와 피드백이 용이하지만 관리가 복잡함. 보헴이 제안하였음. 유지보수 과정 필요 없음

+ 델파이 모형
+ 폭포수 모형 : 선형 순차적 모델, 앞 단계가 완료되어야만 넘어갈 수 있음, 관리가 용이하나 요구사항 반영이 어렵다
+ 기능점수 모형 : 산정 기법


### 소프트웨어 설계 과정
+ 소프트웨어 생명 주기: 분석 -> 설계 -> 구현 -> 시험
1. 계획 수립
2. 요구사항
    1) 요구사항 도출(Elicitation) : 사용자 스토리, 인터뷰, 브레인스토밍, 프로토타이핑(대충 빠르게 구현해둔 프로그램으로 피드백 받음) 등 (타당성 조사)
    2) 요구사항 분석(Analysis) : 모델링 다이어그램 - Usecase, Sequence, Object, State, Data Flow, Data Model, 요구사항 분류, 할당, 협상

            자료 흐름도(DFD), 자료 사전(DD)
    
        기능적 요구사항 - 시스템에서 제공되어야 할 특정 기능. 데이터 모델, 데이터 흐름 처리 모델, 프로세스 모델
        
        비 기능적 요구사항 - 시스템의 품질이나 기능적 요구사항 외 고려해야 하는 제약사항. 성능, 보안, 아키텍처, 안정성 등
        
    3) 요구사항 명세(Specification) : **정형 (ex. Z, VDM, Petri-Net, CSP 등) vs 비정형 (ex. FSM, ER, Decision Table, State table,  UseCase 등)**
    4) 요구사항 확인(Vadication) : 검토 - **동료 검토, 워크스루(사전 검토 후 짧은 검토 회의), 인스펙션(프로그램 실행 없이 각 단계 결과물 검토) -> 정적 테스트 방법**, 프로토타이핑, 모델 검증, 인수 
3. 설계
4. 개발
5. 유지보수



### CASE
↑ 위의 소프트웨어 생명주기 전 과정을 자동화 할 수 있도록 지원하는 자동화 도구
1. 종류
+ Upper CASE(상위 CASE) : 계획 수립, 요구분석, 기본설계 -> 다이어그램으로 표현, 자료흐름도 작성, 
+ Middle CASE : 상세설계 작업 지원하여 화면, 출력 등의 작성
+ Lower CASE(하위 CASE) : 시험, 유지보수 작업 지원 -> 소스코드, 시스템 명세서 생성
+ I-CASE 통합 ex) Rational ROSE, COOL
2. CASE 도구의 원천 기술 : 구조적 기법, 프로토타이핑 기술, 자동 프로그래밍 기술, 정보 저장소 기술, 분산처리 기술 (일괄처리 X)

### 소프트웨어 개발 방법론
1. 구조적 방법론 : 도형화된 도구를 이용해 정형화된 분석 절차에 따라 사용자 요구사항을 파악하고 문서화
2. 정보공학 방법론: 기업 정보 시스템에 공학적 기법을 적용
3. 객체지향 기법론
4. 컴포넌트 기반(CBD; Component Based Design) 방법론
5. 제품 계열 방법론
6. 에자일 방법론

### 에자일(Agile) 개발 방법론
-> 좋은 것을 빠르고 낭비 없게 만들기

1. **XP** (Extreme Programming)
    + 문서화의 단점 보완
    + 요구사항에 유연하게 대응하기 위해 고객의 참여과 개발 과정의 반복을 극대화하여 개발 생산성 향상
    + Pair Programming, Collective Ownership, Test-Driven Development, Whole Team, Continuous Integration, Refactoring, Small Releases
    + 5가지 가치 : 의사소통, 단순함, 피드백, 용기, 존중
2. 스크럼(Scrum) : 팀이 중심이 되어 개발의 효율성 증대 / 제품책임자 PO, 스크럼 마스터 SM, 개발팀 DT / 스프린트 (Sprint)
3. Lean
4. 기능 중심 개발(FDD: Feature Driven Development)
5. 칸반(Kanban)


### 성능 분석 지표
* 주로 사용하는 지표: 응답시간, 처리량(업무량), 가용성, 사용률
* DBMS: 가용성, 성능, 상호호환성, 구축비용


### 소프트웨어 아키텍처
1. 품질 속성

        시스템 품질 속성 : 가용성, 성능, 사용성, 변경용이성, 보안성, 확장성, 기능성
        비즈니스 품질속성 : 시장 적시성, 비용과 혜택, 예상 시스템 수명
        아키텍처 품질속성 : 개념적 무결성, 정확성과 완결성, 구축가능성

2. 아키텍처 패턴(구조)
        
        클라이언트-서버 : 다수의 클라이언트와 하나의 서버
        그래프
        파이프-필터 모델 : 서브시스템이 입력 데이터를 받아 처리하고 결과를 다른 시스템에 보내는 작업 
        n-Tier 모델 : 계층 구조, 하위층이 제공하는 서비스를 상위층의 서브 시스템에서 사용
        MVC 모델 : Model-View-Controller
        Master-Slave 아키텍처 : 마스터 프로세스가 일을 분배하고, 슬레이브는 전달된 기능 수행 -> 분할 시스템 (병렬처리), 실시간 시스템
        데이터 중심 아키텍처 : 공유 데이터 저장소를 통해 접근자 간의 통신이 이루어지므로 각 접근자의 수정과 확장이 용이 (Repository형, Blackboard형)



### 미들웨어
클라이언트와 서버를 연결하는 시스템 소프트웨어 -> 분산 시스템, 투명성 제공
+ DB
+ RPC : 원격 프로시저 호출 (Remote Procedure Call)
+ MOM : 비동기형 메시지 전달 미들웨어
+ TP-Monitor : 트랜잭션 처리 모니터
+ ORB : 객체 요헝 브로커, CORBA 표준 스펙 구현
+ **WAS**

### 시스템 연계 기술
개발할 시스템과 내, 외부 시스템을 연계할 때 사용되는 기술
+ DB 링크 : 수신 측에서 생성한 DB 링크를 송식 측에서 직접 참조
+ API / Open API : 송신 시스템의 DB에서 데이터를 읽어와 제공하는 Application Programming Interface
+ 연계 솔루션 : EAI 서버와 송, 수신 시스템에 설치되는 클라이언트를 이용하는 방식
+ 소켓(Socket) : 서버는 통신을 위한 소켓을 생성하여 포트를 할당, 클라이언트의 통신 요청 시 연결하여 통신하는 네트워크 기술
+ Web Service : 웹 서비스에서 WSDL, UDDI, SOAP 프로토콜을 이용하여 
      
### 연계 시스템
+ 연계 시스템의 구성 : 송신 시스템, 수신 시스템 (-> 직접연계 방식), 중계 서버 (-> 간접연계 방식)

### 공통 모듈 작성 원칙
정확성, 명확성, 완전성, 일관성, 추적성
        

### 기타 키워드
+ Fan-out: 하나의 모듈이 제어하는 하위 모듈의 수
