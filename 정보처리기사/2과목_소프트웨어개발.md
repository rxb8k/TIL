# 🍣 제2과목 소프트웨어 개발


## 📌 소프트웨어 테스트

### 테스트 기법
1. 실행 여부에 따른 테스트 : 동적 vs 정적
    + 정적 테스트 : 워크스루, 인스펙션, 코드검사
    + 동적 테스트 : **화이트박스(개발자가 코드 분석) vs 블랙박스(명세서 바탕으로 사용자가 직접 테스트)**

        + 화이트박스 테스트
        
            개념 : 모든 문장을 한 번 이상 수행, 모듈 작동 관찰
            
            종류 : **기본 경로 테스팅(기초경로검사, 사이클을 포함할 수 있음), 제어 구조 검사 - 반복 경로(루프) 검사, 제어구문 검사, 데이터 흐름 검사**

            검증 기준 : 문장, 분기, 조건, 분기/조건

        + 블랙박스 테스트
            
            개념 : 소스코드 참조 없이 외부에 드러난 인터페이스만을 기반으로 사용자가 직접 테스트
            
            종류 : **동치 클래스 분해(동등 분할 기법, 타당한 입력과 타당하지 않은 입력을 균등히 하여 테스트 케이스 확인), 경계값 분석, 원인 효과 그래프 기법(Cause-Effect Graphing Testing, 효용성이 높은 테케를 선정해 테스트), 결정 트리, 상태 전이, 오류 예측 기법(과거 경험이나 감각으로)**

2. 테스트 기반에 따른 테스트 : 구조기반 vs 명세기반 vs 경험기반
    종류|의미|
    ---|---|
    명세 기반 테스트|요구사항에 대한 명세를 테스트케이스로 만들어 확인. 동등 분할, 경계값 분석 등
    구조 기반 테스트|논리 흐름에 따라 테케 작성 및 확인. 구문 기반, 결정 기반, 조건 기반 등
    경험 기반 테스트|유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트. 에러 추정, 체크 리스트, 탐색적 테스팅 등

3. 시각에 따른 테스트 : Verification vs Validation

    + 검증(Verification) : 소프트웨어 개발 과정을 테스트 -> 기능을 정확히 수행하는가?
    + 확인(Validation) : 소프트웨어 결과를 테스트 -> 사용자의 요구사항을 만족시키는가?

4. 목적에 따른 테스트 : 회복, 안전, 강도, 성능, 구조, 회귀, 병행

5. 자동화 기법 : 설계 자동화, 실행/모니터링 자동화, 관리 자동화

### 테스트 레벨 - 개발 단계에 따른 테스트
> 개발 : 요구사항 -> 분석 -> 설계 -> 구현

> 테스트 : 단위 -> 통합 -> 시스템 -> 인수

1. 단위 테스트 : 구현된 각 **단위 모듈**의 기능 수행 여부를 판정, 모듈 간 상호작용은 해당 X

2. 통합 테스트 : **하향식(Stub, 모듈 간의 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공) vs 상향식(Driver)**
     - 하향식 통합 테스트 : BFS & DFS, 상위 모듈은 있지만 하위 모듈 개발이 완료되지 않은 경우 Stub 사용 (하위 모듈의 역할을 함)
     - 상향식 통합 테스트 : 각 통합된 클러스터, 하위 모듈은 있지만 상위 모듈이 없는 경우 간이 소프트웨어 Driver 사용, 필요에 따라 매개변수를 전달하고 모듈을 수행한 후의 결과를 보여줄 수 있음
     - 혼합식 통합 테스트(샌드위치)
     - 회귀 테스팅 : 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 **새로운 오류**가 있는지 확인하는 테스트

3. 시스템 테스트
    + 테스트 케이스 : 프로그램 요구사항 준수 확인을 위해 구성된 테스트 항목
        - 구성 요소: 식별자, 테스트 항목, 입력 명세, 출력 명세, 환경 설정, 특수 
    + 테스트 오라클 - 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참값을 대입하여 비교하는 기법. True or False 판단 : True 오라클, Sampling 오라클, Heuristic 오라클, 일관성 검사 (참샘휴일;)

4.  인수 테스트 : **알파 테스트(개발자랑 같이), 베타 테스트**


### 소프트웨어 테스트의 기본 원칙
1. 테스팅은 결합이 존재함을 밝히는 활동
2. 완벽한 테스팅은 불가
3. 테스팅은 개발 초기에 시작해야
4. **결함 집중 (Defect Clustering) : Pareto의 법칙 - 20%:80%, 오류의 80%는 전체 모듈의 20% 내에서 발생**
5. 정황(Context)에 의존해야
6. 살충제 패러독스 : 주기적으로 테스트 케이스 바꿔야
7. 오류ㅡ부재의 궤변 : 결함이 없다고 해도, 사용자 요구사항을 만족시키지 못했다면 품질이 높지 못함



### 소프트웨어 품질
1. 표준: 

+ ISO/IEC 9126- 기능성, 주어진 시간 동안 주어진 기능 수행 정도 - 신뢰성, 사용자 기준 - 사용성, 효율성, 유지보수성, 이식성(Portability)
+ McCall의 품질 인자 - 제품 개선 (유지보수성, 유연성, 테스트 용이성), 제품 운영 (정확성, 신뢰성, 효율성, 무결성, 유용성), 제품 전이 (이식성, 재사용성, 상호운용성)
+ ISO/IEC 12119 - 패키지 소프트웨어 품질평가 기준

2. 품질 분석 도구
   구분|도구명|설명|
   ---|---|---|
   정적 분석 도구|pmd, cppcheck, 소나큐브, checkStyle, CodeSonar, splint|소스 코드 분석|
   코드 복잡도|ccm, cobertura, McCabelQ|~|
   동적 분석 도구|Avalanche, Valgrind|~|


## 📌 소프트웨어 개발


### 트리(Tree)
1. 구조
+ 노드 종류 3개 - 루트 노드, **단말 노드(leaf node) - 자식이 없는 노드**, 내부 노드(internal node)
+ **트리의 차수(Degree)** 노드의 차수 중 가장 많은 수
+ **트리의 높이** 제일 깊숙히 있는 노드의 깊이
+ 노드의 차수 - 각 노드가 가진 가지의 수

2. 순회 방식 3가지 - PreOrder **R**LR, InOrder L**R**R, PostOrder LR**R**

3. 트리의 검색 효율
+ 이진 탐색트리는 최악의 경우 리스트처럼 되어 O(N)의 검색 성능을 보임
+ 이를 해결하기 위해 2-3트리, AVL 트리, 레드-블랙 트리와 같은 자가 균형 이진 탐색 트리(Self Balancing Bianry Search Tree)를 사용함

### 그래프
무방향 vs 방향

최대 간선 수: n(n-1)/2, n(n-1)


### 자료구조
* 데크(Deque) : 양방향 입출력이 가능한 선형 자료 구조


### 정렬 알고리즘
+ 소요 시간 : **O(nlogn) 힙합 합병, 힙 정렬 < O(n^2) 나머지 정렬**

~> 정렬 알고리즘 정리 필요 420p

+ Selection Sort : 정렬되지 않은 값 중 가장 작은 값을 선택 후 정렬되지 않은 첫번째 요소와 바꿈
+ Quick Sort : 배열을 두 부분으로 나눈 후 부분 배열에 독립적인 정렬을 순환적으로 적용
+ Bubble Sort : 왼쪽부터 모든 인접한 두 키를 비교한 후 왼쪽의 키가 더 크면 오른쪽과 자리바꿈

### 시간 복잡도 측정
    O(1) < O(log n) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2n) < O(n!)


### 모듈 연계
+ EAI
+ ESB : 어플리케이션 간 표준 기반 인터페이스 제공
+ 웹 서비스 : SOAP (HTTP, SMTP 등을 활용하여 XML 기반 메시지를 네트워크 상에서 교환하는 프로토콜) + UDDI + WSDL

### EAI (Enterprise Application Intergration) 구축
시스템 통합 인터페이스 구축 방식

   방식|설명|장단점|
   ---|---|---|
   Point-to-Point|미들웨어 없이 애플리케이션 연결|솔루션 구매 없어서 저렴하나 변경, 재사용 어려움|
   Hub-Spoke|단일 접점이 허브 시스템에 데이터 전송|모든 데이터 전송 보장되고 확장, 유지보수 용이하나 허브 장애 시 전체에 문제|
   Message Bus|**미들웨어** 활용 통합|뛰어난 확장성, 대용량 처리|
   Hybrid|그룹 내에서는 허브, 그룹 간에서는 메시지 버스|표준 통합 기술, 데이터 병목 현상 최소화|
   
+ +) **ESB**(Enterprise Service Bus) 웹 서비스 중심으로 표준화된 데이터, 버스를 통해 이기종 애플리케이션을 *유연하게* 통합하는 핵심플랫폼 기술 295p

### 알고리즘 설계 기법
+ Divide and Conquer : Top-Down 방식 ex) 퀵 정렬, 병합 정렬
+ DP : 하위 문제 해결(점화식)하고 Bottom-up 방식으로 큰 문제 해결 ex) A* 알고리즘, 피보나치수열
+ Greedy : 매 단계에서 최적의 선택 ex) 다익스트라, 허프만코딩, 최조신장트리
+ Backtracking : 모든 경로 탐색하고 막히면 돌아가서 다시 탐색 ex) DFS

### 반정규화
중복, 통계, 이력, 부분 테이블 추가 -> 자주 사용되는 데이터 I/O 부하 감소 & 읽기 성능 향상


### 해싱 함수
폴딩법, 계수 분석, 제산법 등 레코드 키를 처리하는 방식들.. *어떻게 레코드 주소를 결정하는가?* 311p
+ 폴딩법 : 키를 여러 부분으로 나누고 나눈 부분의 각 숫자를 더하거나 XOR
+ 제산법 : 키를 임의의 양수로 나눈 나머지
+ 기수변환법 : 키를 특정 진법의 수로 간주하여 다른 진법으로 변환
+ 숫자분석법 : 숫자 분포를 활용
+ 계수 분석 : 숫자 분포 파악, 비교적 고른 자리부터 필요한 자리만큼 -> 자구에서 배운 듯?



## 📌 소프트웨어 관련 도구 활용


### 빌드 도구
지속적인 통합 개발 환경에서 유용하게 활용된다. 
+ Ant : 아파치에서 개발, Java 공식 빌드 도구
+ Gradle : 안드로이드 앱 개발환경, Groovy 기반, 태스크 단위 실행, 한스 도커에서 개발   
+ Jenkins : 형상관리 도구와 빌드 도구를 연계하여 자동화 및 통합을 수행
+ Maven : 아파치에서 Ant 대안으로 개발, 의존성 설정


### 인터페이스 구현 검증 도구 (테스트 프레임워크)
+ xUnit: 단위 테스트 프레임워크
+ STAF : 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크 / 각 테스트 분산 환경에서 데몬 사용하고 통합하여 자동화
+ FitNesse :  웹 기반 테스트 케이스 지원
+ NTAF : Naver 테스트 자동화 프레임워크. FitNesse(협업)+STAF(재사용성 및 확장성)
+ Selenium : 웹 애플리케이션 테스트 프레임워크, 다양한 브라우저 및 언어 지원
+ watir : RUBY 기반 웹 애플리케이션 테스트 프레임워크
구현 기술: AJAX(JS를 사용하여, 클라이언트-서버 간 XML 데이터 주고 받는 비동기 통신 기술)


### 애플리케이션 배포도구
1. 저작권 보호 기능

암호화, 키 관리, 암호화 파일 생성, 식별 기술, 저작권 표현, 정책 관리, 크랙 방지, 

2. 활용 시 고려사항

암호화/보안, 이기종 연동, 지속적 배포 CD-Continuous Deployment (+CI, Continuous Intergration)

### 소프트웨어 패키징
+ 실행 파일을 묶어 배포용 설치 파일을 만드는 것
+ 기능 식별 - 모듈화 - 빌드 진행 - 사용자 환경 분석 - 패키징 및 적용 시험 - 패키징 변경 개선 - 배포

### 디지털 저작권 관리 DRM
1. 구성 요소 : 제공자 -> 분배자 -> 소비자 + 클리어링 하우스
+ 컨텐츠 제공자 : 컨텐츠+메타데이터 -> 패키저 (암호화한 컨텐츠로 변환)
+ 컨텐츠 분배자 : 커머스, P2P
+ 소비자 : 응용 프로그램, DRM 컨트롤러, 보안 컨트롤러, 라이센스
+ 클리어링 하우스 : 사용권한 정책
2. 기능 : 크랙 방지, 정책 관리, 암호화 및 키 관리, 라이센스 발급 및 관리, 식별체계 표현, 인증
그림 533p


## 📌 기타 키워드 정리


### 소프트웨어 형상 관리 (= 버전 관리)
1. 정의: 개발 과정에서 발생하는 변경을 관리하는 활동
2. 대상: 소스 코드, 실행 파일(바이너리 파일), 설계 문서, 문서화 자료 등 / 개발 비용은 X
3. 팀: CCB (Configuration Control Board)
4. 기능
    + 형상 식별 : 관리 번호 부여, 계층 구조로 구분
    + 버전 제어
    + 형상 통제 : 기준선 반영
    + 형상 감사 : 기준선 무결성 평가하여 승인
    + 형상 기록
5. 동작: Checkout & Update, Checkin & Commit 등
6. 과정: Import > Checkin > Commit > Update > Diff
7. 효과: 배포본 관리, 소스 수정 제한. 동시개발 가능 / 비용관리는 아님! 비용 관리는 PMS(Project Management System)
8. 도구 : GIT, SVN(서브비전, CVS 개선, Apache)


### 물리데이터 파티션 설계
범위 분할, 해시 분할, 조합 분할

### 데이터베이스의 3단계 스키마 구조 -> 데이터 독립성
외부 스키마, 개념 스키마 (Only one), 내부 스키마 (=물리적 스키마)

### 코드 관련 표현
외계인 코드(Alien Code), 스파게티 코드, 클린 코드
+ 클린 코드 작성 원칙 : 가독성, 단순성, 의존성, 중복성, 추상화 / 하나의 개체가 여러 가지 작업을 수행해서는 안 됨, 주석 많이

### 소프트웨어 재공학
기존 소프트웨어를 버리지 않고 기능을 개선하여 새로운 소프트웨어로 재활용 177p

재개발에 비해 리스크 감소, 비용 절감, 명세 오류 억제, 개발 시간 단축 등의 장점

### 소프트웨어 개발 과정&결과 용어
+ Fault : 오류(Error)가 있을 때 발생하며, 제거하지 않으면 제품이 고장(Faliure)를 일으키게 하는 요소
+ Mistake : 개발자의 의도치 않은 실수
+ 애플리케이션 배포 : 개발이 완료된 소프트웨어를 고객에게 전달하기 위해 패키징, 설치 및 사용 매뉴얼 


### 기타 키워드
McCabe cyclomatic 척도 (=회전복잡도, 순환복잡도) 169p

통합 개발 환경(IDE)

전위식 후위식 변환 참고 406p
