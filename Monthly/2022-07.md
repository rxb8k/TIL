# 2022. 07
## 이달의 목표
1. 제일 집중할 것은 **알고리즘**이다. 꾸준히 부족했던 분야임에도 불구하고, 학기 중에는 너무 바빠 공부를 따로 하지 못했다.

    감사하게도 2주간 삼성SDS 하계 대학생 알고리즘 특강을 들을 수 있게 되었다. 기본 지식이 매우 부족한 상태에서 특강을 듣게 되어 두렵기도 하지만, 주어진 기회에 감사하며 최선을 다할 것이다.
2. **TIL(Today I Learned)** 을 시작했다. 꾸준함의 힘을 믿고, 매일 배우고 느낀 것을 소소하게나마 꾸준히 기록해 나갈 것이다.
3. **블로깅!** 방학 때 본격적으로 시작하려고 계획했던 것들 중 하나다. 올리려고 계획 중인 포스팅부터 차근차근 시작해보자.


---


## Today I Learned

### 7/4 월
+ 알고리즘은 완전탐색에서 시작한다.
+ DFS, BFS
    탐색 방법|구현|활용|
    |------|---|---|
    |DFS|재귀함수, 스택|백 트래킹, 단절선 단절점 찾기, 위상정렬, 사이클 찾기|
    |BFS|큐|최단경로 찾기, 위상정렬|

    + DFS는 일반적으로 재귀함수로 구현하고, Stack Overflow 발생 시 스택으로 구현한다. 
    + 모든 정점에 대해 탐색하면, Tree의 집합이 만들어지고(?) 탐색 정보도 얻을 수 있다.
+ 특정 데이터를 제거해야 할 때, 정렬을 사용하면 유용하다.




### 7/5 화
+ 시간복잡도, 공간복잡도
+ Compare 함수
    + 2개의 데이터 위치에 대해 Swap 여부를 결정한다. 바꾸지 않으면 True
    + 정수 외에도 struct 타입도 비교할 수 있어 사용한다. 다차원 배열에 대해서도 사용은 할 수 있으나, 권장은 하지 않는다.
+ C++의 표준 라이브러리를 사용한 정렬

    ```
    #include <algorithm>
    void sort(first, last);
    ```
+ 정렬은 유일성 검사, 중복 제거, 빈도 수, 이분 탐색 등에 활용할 수 있다.
+ 어려운 문제는 행렬 계산을 통해 O(logN)으로 풀이할 수도 있다.
+ 거듭제곱 연산
+ 비트 연산
+ 피보나치 수열 : 재귀함수 O(2^N), 반복문 O(N), 동적계획법 O(N), 행렬 (O(logN))

### 7/6 수
+ Serializer란? django에 저장되어 있는 모델 인스턴스를 REST API에서 사용하는 JSON의 형태로 바꿔주는 것 (출처: https://hangjastar.tistory.com/m/206)

+ Generics API

    Generics API를 사용하지 않았을 때의 코드 : 모든 필드를 직접 작업해주어야함

    ```
        blog.title = ~
        blog.writer = ~
        ...
    ```
    Generics API를 사용했을 때의 코드

    ```
    from rest_framework import generics
    class BlogList(generics.ListCreateAPIView):
        queryset=Blog.objects.all()
    ```

    Generics API에서 기본으로 RetriveAPIview 등 CRUD 관련 view를 제공하고 있다.

+ join(리스트) -> 문자열
+ REST API
    + PUT과 PATCH method의 차이
    + DELETE method 사용해 삭제 기능을 손쉽게 만들 수 있다.
+ DB에 따라 max length가 먹히지 않는 경우도 있다.
+  Generic API, Serializer에 대해 더 자세히 공부해볼 것이다.


### 7/7 목
+ 알고리즘에 활용될 수 있는 여러 **정수론** 이론을 익혔다. 
+ 내용 나중에 보충

### 7/8 금
+ C++에서 **조합**을 이용해 다양한 경우의 수를 구하는 방법을 익혔다. 나는 팩토리얼과 조합(Combination) 계산 함수를 직접 만들어서 구현하였는데, 알고리즘에서 조합론을 사용할 때에는 더 좋은 방식이 있음을 알게 되었다.
+ 내용 나중에 보충

### 7/9 토
+ DFS와 BFS 알고리즘을 구현하기 위해, 먼저 **그래프** 구조에 대해 알아보았다. 다음과 같이 벡터를 활용하여 n개의 정점(노드)과 m개의 간선으로 이루어진 그래프를 구현할 수 있다. 각 벡터는 각각의 정점을, 해당 벡터의 요소는 해당 정점에 연결된 정점을 나타낸다.

    ```
    
    vector<int> graph[n+1]; // 정점을 나타내는 벡터 총 n개

    for(int i=0; i<m; i++){ // 간선의 개수만큼
        int u, v;
        graph[u].push_back(v);
        graph[v].push_back(u); // 양방향인 경우에만 추가
    }
    ```

+ 양방향 그래프는 무방향 그래프인가? 답은 O
+ 재귀를 이용해 DFS를 구현했다. 자세한 설명은 [백준 1260번 문제 풀이](https://github.com/rxb8k/Algorithm/blob/main/Silver/1260_DFS%EC%99%80BFS.cpp)에 주석으로 적었다.
+ vector 타입의 변수를 초기화 할 때에는 fill() 함수를 유용하게 사용하자.
+ 도움이 된 자료: https://twpower.github.io/73-how-to-implement-dfs-and-bfs-in-cpp

### 7/10 일
+ 어제 그래프의 방향성에 대해 완전히 이해하지 못했던 부분이 있었다. [@sonmh79](https://github.com/sonmh79)의 도움으로, 다음과 같은 내용을 이해하게 되었다.
    > 그래프에 방향이 있다는 것은, 그래프 내에 A->B로 연결된 두 정점에 대해 B->A와 같이 이동할 수 없음을 의미한다. 무방향 그래프에서는 A->B와 B->A 모두 가능하다. 따라서, 양방향 그래프 == 무방향 그래프이다.
+ 큐를 이용해 BFS를 구현했다. 

### 7/11 월
+ 완전 그래프는 정규 그래프이고(Why?) 완전 그래프에 비해 간선이 적은 그래프를 희소 그래프라고 한다.
+ 그래프 표현 방식
    1. 간선 그래프
    2. 인접 행렬: 어떤 정점이 연결되어 있는지 간선 그래프보다 쉽게 알 수 있으나 그래프의 크기가 크면 메모리 차지가 크다. 간선의 가중치가 없다면 인접 행렬은 대각선으로 대칭이다. 

        인접 행렬로 최단 거리를 구할 때, 만나지 않는 정점의 관계를 어떻게 표현할지 생각해보는 것이 중요하다. 0보다는, 간선의 최대 길이를 능가하는 매우 큰 값을 부여하는 것으로..

    3. 인접 리스트: 제일 많이 쓰이는 방식! 토요일에 이해한 그래프가 이 방식이었다. 정렬은 굳이 필요하진 않으나, 정점 번호가 낮거나 높은 것부터 탐색해야 하는 조건이 있는 경우에는 정렬을 해서 붙인다. 
    
    => 간선 리스트 vs 인접 행렬 vs 인접 리스트 ? 인접 행렬은 간선이 많을 때에 효율적, 인접 리스트는 정점에 비해 간선의 개수는 적을 때(희소 그래프)에 효율적. 전체 가중치를 봐야 할 때는 간선 리스트가 좋음.

+ Floyd-Warshall 알고리즘 - 나중에 더 공부해보기
+ 새롭게 알게된 자료 구조
    + Union Find (Disjoint Set)
    + DAG(Directed Acylic Graph): 싸이클이 없는 방향 그래프. 선행자와 후행자가 있음.
    
+ 그래프를 사용해 문제 풀이를 할 때, 어떤 그래프를 사용해 추상화를 할 것인지 고민하여야 한다. 방향성, 싸이클 유무, 연결 그래프 여부 등.. 

    ex) 트리는 방향성이 없는 그래프이니 방향성이 필요한 문제에서는 사용 X
+ 위상 정렬(Topological Sort): DAG에서 그래프의 방향성을 거스르지 않고 정점을 나열하는 것 (우선순위에 따라 배치)


### 7/12 화
+ 최단 거리 알고리즘: 최소 비용의 연결 그래프를 만들기. 그래프의 간선을 가중치대로 정렬하고, 각 위치에서 다음 간선을 찾을 때 작은 쪽으로 이동하도록 한다!
    + 크루스칼: 간선을 가중치 오름차순으로 정렬
    + 프림: Mixheap 사용, 현재 나의 cost를 가지고 결정
    + 다익스트라(Dijkstra) : 지금까지 cost의 합을 가지고 결정

### 7/13 수
+ 최단 거리 알고리즘 : BFS, Dijkstra, Bellman-Ford, Floyd-Warshall 
+ 다익스트라 알고리즘

    + 기본 로직은 BFS와 완전히 같다. 
    
        BFS의 기본 모토는 '출발 정점에서 가까운 정점부터 탐색한다'이다. **먼저 탐색하는 정점이 나중에 탐색하는 정점보다 시작 지점으로부터 최소 멀지는 않다**는 게 보장됨. 반면 DFS는 '깊이'를 탐색하므로 얼마나 깊게 갈 수 있는지를 추론할 때 유리하다. 앞만 보고 달리는 알고리즘.
    + 간선에 가중치가 주어질 때
    
        그러나 이 경우에는 위의 보장이 성립하지 않는다. 따라서 큐 등 자료구조에서 pop을 수행할 때 크기 비교를 해야 한다. 가중치를 같이 저장하고 있다가 이를 비교해서 **자료구조 안에 있는 정점 중 가중치가 가장 작은 정점을 선별**해서 내보낸다. 따라서 **Minheap**을 사용한다. 자료가 나가거나 들어올 때마다 heapify가 진행된다(O(logn)). 
    + 즉, 다익스트라 알고리즘은 **큐 대신 Minheap을 사용하는 BFS**라고 할 수 있다.
    + 음수 간선이 존재할 수 없다. 
    
        다익스트라의 자료구조에는 다른 경로의 가중치가 임시로 같이 저장되고 최솟값을 찾아 이동하는데, 이러한 로직에 혼란을 줄 수 있다. 또한 음수 가중치로 인해 싸이클을 돌 때마다 가중치가 감소할 경우에는 최단 경로가 없는데, 다익스트라에서는 가중치 합이 감소하므로 최단 경로라고 판단할 것이다. 이러한 이유로 Dijkstra에서는 음수 간선 처리가 근본적으로 매우 곤란하다.

    + O(V^2)의 시간복잡도 -> 우선순위 큐(Priority Queue)를 사용. 더 공부하기

+ 벨만-포드 알고리즘
+ 플로이드-워셜 알고리즘
    + 모든 정점 V를 시작점 및 도착점으로 한, 전체 경로 V^2개에 대한 map이 필요하다. **인접 행렬** 형태.
    + A->B까지의 최단경로는 중간 지점 K를 경유하거나, 경유하지 않거나 둘 중 하나이다. 모든 K에 대해 거리를 확인하므로, **각각의 데이터에 대해 V번의 갱신의 기회**가 주어진다.
    + A-K-B가 최단경로이면 A-K와 K-B도 최단경로이다.
    + O(V^3)의 시간복잡도. VxV, 총 V^2개의 데이터에 대해 V번의 갱신이 이루어지므로. 알고리즘 속도가 느린 편이기 때문에 보통 300~500개 정도의 데이터를 쓰는 문제가 출제된다.
    + 구현
        1. VxV의 인접행렬 생성
        2. 모든 정점들에 대해 cost 갱신
        3. 2번을 반복하면, 인접행렬에는 최적의 값들만이 저장되게 된다.

### 7/14 목
하루 휴식


### 7/15 금
+ DRF를 사용한 인증
    rest_framework 앱의 authtoken을 활용한다. Token이란 일종의 여권과 같은 개념으로, 정보를 전달하고, 신원 또한 확인할 수 있게 해준다.
