# 최단경로 알고리즘
알고리즘|시간복잡도|활용|
---|---|---|
다익스트라|O(ElogV)|한 지점에서 다른 모든 지점까지의 최단 경로 계산
플로이드 워셜|O(V^3)|모든 지점에서 다른 모든 지점까지의 최단 경로 계산
---
## 다익스트라 (Dijkstra) 알고리즘

+ **한 지점에서 다른 지점까지의 최단 경로**를 구해야 하는 경우
+ 음의 간선 X

### 분류
+ 기본 로직은 **BFS**와 완전히 같다. **출발 정점에서 가까운 정점부터** 탐색한다.
+ 매번 가장 비용이 적은 노드를 선택한다. 따라서 **그리디** 알고리즘으로 분류된다.


### 동작 원리
        방문하지 않은 노드 중 현재까지의 거리가 가장 짧은 노드를 선택한다
        => 한 단계 당 하나의 노드에 대한 최단 거리를 확실히 찾는다.

1. 출발점 설정
2. 각 지점까지의 최단 거리를 저장하는 **최단거리 테이블** 초기화
3. 방문하지 않은 노드 중 **거리가 가장 짧은 노드 선택** 🙌

    ➡️ 크기 비교를 수행하여, 가중치(거리)가 가장 작은 정점을 선택한다.

4. 비용 계산하여 최단거리 테이블 갱신
5. 3~4 반복


### 구현
+ 위 과정 중 3.을 수행할 때, 크기 비교를 매번 해주지 않고 **우선순위 큐**처럼, 자동으로 작은 수부터 내보내는 자료구조를 사용하여 시간복잡도를 줄일 수 있다.

    |우선순위 큐 구현 방식|삽입 시간|삭제 시간|
    |------|---|---|
    |리스트|O(1)|O(N)|
    |힙 ✔️|O(logN)|O(logN)|


        즉, 다익스트라는 큐 대신 우선순위 큐(Minheap)을 사용하는 BFS



### 시간복잡도
원래는 O(V^2)의 시간이 소요되나, 우선순위 큐를 사용하면 시간복잡도를 크게 줄일 수 있다.

자료가 나가거나 들어올 때마다 heapify가 진행되므로, 위의 구현 방식을 따라 구현하면 **O(ElogV)** 가 보장된다. *(E- 간선의 개수, V-노드의 개수)*


---
## 플로이드 워셜 (Floyd-Warshall)
+ **모든 지점에서 다른 모든 지점까지의 최단 경로**를 구해야 하는 경우

## 분류
+ 노드의 개수만큼의 단계를 반복하며 **점화식에 맞게** 최단거리 2차원 리스트를 갱신하므로 **다이나믹 프로그래밍**으로 분류된다.

## 동작 원리
        [A에서 B로 바로 가는 비용]과 [A에서 K를 거쳐 B로 가는 비용]을 비교해, 더 작은 값으로 갱신한다.

+ 각 K번의 단계에서의 점화식

        Dab=min(Dab, Dak+Dkb) (k번의 단계에 대해)

## 구현
+ 현재 노드를 제외하고, N-1개 노드 중 서로 다른 노드 (A, B) 쌍을 선택하여 [A -> 현재 노드 -> B로 이동하는 비용]을 계산해 최소 값으로 갱신한다. 

    즉, 단계마다 n-1P2개의 쌍을 확인한다.


        for (int k = 1; k <= N; k++) { // k : 경유지
                for (int i = 1; i <= N; i++) { // i : 출발지
                        for (int j = 1; j <= N; j++) { // j : 도착지
                                if (AM[i][j] > AM[i][k] + AM[k][j]) {
                                AM[i][j] = AM[i][k] + AM[k][j];
                                }
                        }
                }
        }


## 시간복잡도
노드가 N개일 때 N단계가 수행되며, 단계마다 O(N^2)의 연산을 통해 현재 노드를 거쳐가는 모든 경로를 고려하므로 시간복잡도는 **O(N^3)**

---
## 벨만 포드 (Bellman-Ford)